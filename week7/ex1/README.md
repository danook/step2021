# STEP Week 7 宿題1
## 概要
行列積を計算する以下のプログラムを考える。
```
for (int i = 0; i < size; ++i){
    for (int j = 0; j < size; ++j){
        for (int k = 0; k < size; ++k){
            c[i][j] += a[i][k] * b[k][j];
        }
    }
}
```
このforループを入れ替えることで計算時間にどのような影響が出るかを調べた。

## 結果の予想
はじめに`c[i][j]`のみについて考えると、各ループの順番ごとにキャッシュヒットは以下のようになる。

* `c[0][0] -> c[1][0] -> ... -> c[n-1][0] -> c[0][1] -> c[1][1] -> ...`という順にアクセスするよりも、`c[0][0] -> c[0][1] -> ... -> c[0][n-1] -> c[1][0] -> c[1][1] -> ...`という順の方が、メモリ内で隣接するデータに連続してアクセスすることになるので、キャッシュヒット率が高くなる。そのため、iのループがjのループより外側にあった方が、内側にあるよりも格段に高速になる。

* kのループ内では`c[i][j]`は不変であるので、kのループがより内側にあったほうが高速になる。

これらから考えると、`c[i][j]`へのアクセス時間は
i-j-k < i-k-j < k-i-j << j-i-k < j-k-i < k-j-i
となると予想される。

同様に考えて、
* `a[i][k]`へのアクセス時間は
i-k-j < i-j-k < j-i-k << k-i-j < k-j-i < j-k-i

* `b[k][j]`へのアクセス時間は
k-j-i < k-i-j < i-k-j << j-k-i < j-i-k < i-j-k

となると予想される。
これらから、行列積の計算にかかる時間、つまり`c[i][j], a[i][k], b[k][j]`のアクセスにかかる合計時間は
**i-k-j < i-j-k ~ k-i-j < j-i-k ~ k-j-i < j-k-i**
となると予想される。

## 結果
行列のサイズn=800とした。5回測定して平均を取った。
**i-j-k**: 9.0626 sec.
**i-k-j**: 6.5046 sec.
**j-i-k**: 7.6322 sec.
**j-k-i**: 10.3536 sec.
**k-i-j**: 7.5074 sec.
**k-j-i**: 10.229 sec.

c[i][j], a[i][k], b[k][j]

c[i][j], b[k][j]
i-k-j
k-i-j

a[i][k]
j-i-k
i-j-k




* j-i-kが予想より速く、i-j-kが遅かった。
* それ以外は大方予想通りだった。