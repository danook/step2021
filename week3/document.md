# 概要
[モジュール化された計算機のプログラム](https://github.com/xharaken/step2/blob/master/modularized_calculator.py)に機能を追加し、

* 掛け算(*)、割り算(/)
* ()によって順序指定した演算

に対応させた。これらではいずれも計算の順序の指定が必要になるので、式の中の各演算子(+-*/)に計算の順序を表す属性priorityを保持し、priorityの大きいものから計算を行うことで実現した。

# アルゴリズム
## 式のトークン化
数に関しては、加減算のみのときと同様にトークン化した。演算子については、トークンに計算の順序を表すキー\'priority\'を加え、その値は

* N重のカッコ内の+,-はpriority=2N
* N重のカッコ内の*,/はpriority=2N+1

と定めた。カッコが何重になっているかについては、式を一文字ずつ読んでいく過程で、\'(\'が登場したら変数bracketsを1増やし、\')\'が登場したら1減らすことで計算した。

これにより、例えば1+2*(3+4)という式は以下のようにトークン化される。

|tokens|\[0\]|\[1\]|\[2\]|\[3\]|\[4\]|\[5\]|\[6\]|
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
|type|NUMBER|PLUS|NUMBER|MULTIPLY|NUMBER|PLUS|NUMBER|
|number|1|-|2|-|3|-|4|
|priority|-|0|-|1|-|2|-|

これにより完成したトークンのリストはtokensに格納する。

## トークン化した式の計算
計算は、priorityの大きい演算子から順に行う。上の例の場合、priorityの最大値が2であるので、
1. はじめにpriority=2の演算子を全て計算してできる新しい式をtokensに代入する
2. 1をpriority=1,0についても繰り返し、最終的にできたtokensはtype=NUMBERの要素1つのみが入った状態となるので、その要素のnumberを返す
という手順で計算する。

priority=2,1,0を計算した直後のtokensはそれぞれ以下のようになる(太字が更新された部分)

### priority=2

|tokens|\[0\]|\[1\]|\[2\]|\[3\]|\[4\]|
|:----:|:----:|:----:|:----:|:----:|:----:|
|type|NUMBER|PLUS|NUMBER|MULTIPLY|**NUMBER**|
|number|1|-|2|-|**7**|
|priority|-|0|-|1|**-**|

### priority=1

|tokens|\[0\]|\[1\]|\[2\]|
|:----:|:----:|:----:|:----:|
|type|NUMBER|PLUS|**NUMBER**|
|number|1|-|**14**|
|priority|-|0|**-**|

### priority=0

tokens|\[0\]|
|:----:|:----:|
|type|**NUMBER**|
|number|**15**|
|priority|**-**|

# 実装における工夫
* 4つの演算子をそれぞれ別の関数として実装するのは冗長なので、readOperatorという1つの関数にまとめなおした。

* トークン化した式の計算をすべてevaluate関数内で行うと長くなるので、evaluate関数内では計算するべき部分を探す作業のみお

* max_priorityを求める処理はtokenize関数内でやってしまう方が楽であったが、そうするとmax_priorityをグローバル変数にする必要がでてくるので、evaluate関数の冒頭においてgetMaxPriority関数を呼び出して求めている。

* readOperator関数内で、4つの演算子についてif文で場合分けして処理するのが冗長に感じられたので、21,22行目のように各演算子についての'type','priority'の値を辞書型でまとめてif文を使わず実装した (ただこれが正しい判断だったのか少し迷っている)。